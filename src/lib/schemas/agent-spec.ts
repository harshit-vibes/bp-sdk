/**
 * Agent Specification Schema
 *
 * Validates agent specifications generated by the Crafter Agent.
 * Gate 2: Craft â†’ Approval transition.
 *
 * Includes separate schemas for manager and worker agents with
 * appropriate validation rules for each type.
 */

import { z } from "zod";

// Filename pattern: lowercase alphanumeric with hyphens, ending in .yaml
const filenameRegex = /^[a-z0-9][a-z0-9-]*\.yaml$/;

// Base agent specification (shared fields)
export const BaseAgentSpecSchema = z.object({
  // Identity
  filename: z
    .string()
    .regex(filenameRegex, "Filename must be lowercase alphanumeric with hyphens, ending in .yaml"),
  name: z
    .string()
    .min(1, "Agent name is required")
    .max(100, "Agent name must be under 100 characters"),
  description: z
    .string()
    .min(1, "Agent description is required")
    .max(500, "Agent description must be under 500 characters"),
  agent_index: z
    .number()
    .int()
    .min(0, "Agent index must be non-negative"),

  // Persona - role and goal with SDK-matching constraints
  role: z
    .string()
    .min(15, "Role must be at least 15 characters")
    .max(80, "Role must be under 80 characters"),
  goal: z
    .string()
    .min(50, "Goal must be at least 50 characters")
    .max(300, "Goal must be under 300 characters"),

  // Instructions - the main prompt
  instructions: z
    .string()
    .min(100, "Instructions must be at least 100 characters")
    .max(10000, "Instructions must be under 10,000 characters"),

  // LLM Configuration
  model: z.string().min(1, "Model is required").default("gpt-4o"),
  temperature: z
    .number()
    .min(0, "Temperature must be between 0 and 1")
    .max(1, "Temperature must be between 0 and 1")
    .default(0.3),

  // Features
  features: z.array(z.string()).default([]),
});

// Manager agent schema
export const ManagerSpecSchema = BaseAgentSpecSchema.extend({
  is_manager: z.literal(true),
  // Manager may have sub_agents linking to workers (empty for single-agent blueprints)
  sub_agents: z.array(z.string()).default([]),
  // Manager doesn't need usage_description
  usage_description: z.string().optional(),
});

// Worker agent schema
export const WorkerSpecSchema = BaseAgentSpecSchema.extend({
  is_manager: z.literal(false),
  // Workers don't have sub_agents (leaf nodes)
  sub_agents: z.array(z.string()).max(0, "Workers cannot have sub_agents").default([]),
  // Workers MUST have usage_description for manager to delegate
  usage_description: z
    .string()
    .min(20, "Usage description must be at least 20 characters")
    .max(500, "Usage description must be under 500 characters"),
});

// Union type for any agent spec
export const AgentSpecSchema = z.discriminatedUnion("is_manager", [
  ManagerSpecSchema,
  WorkerSpecSchema,
]);

// Inferred types
export type BaseAgentSpec = z.infer<typeof BaseAgentSpecSchema>;
export type ManagerSpec = z.infer<typeof ManagerSpecSchema>;
export type WorkerSpec = z.infer<typeof WorkerSpecSchema>;
export type AgentSpec = z.infer<typeof AgentSpecSchema>;

/**
 * Validates an agent spec based on whether it's a manager or worker.
 * Returns a discriminated union result.
 */
export function validateAgentSpecSchema(data: unknown) {
  return AgentSpecSchema.safeParse(data);
}

/**
 * Type guard to check if an agent spec is a manager.
 */
export function isManagerSpec(spec: AgentSpec): spec is ManagerSpec {
  return spec.is_manager === true;
}

/**
 * Type guard to check if an agent spec is a worker.
 */
export function isWorkerSpec(spec: AgentSpec): spec is WorkerSpec {
  return spec.is_manager === false;
}
